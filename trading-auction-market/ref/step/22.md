# 22 - 큐 자료구조 구현과 활용

## 학습 목표

- 큐(queue) 자료구조를 구현할 수 있다.
- 큐의 구동원리를 이해하고 활용할 수 있다.


## 실습 소스 및 결과

- src/main/java/kyh/util/Queue.java 추가
- src/main/java/kyh/tam/App.java 변경

## 실습

### 훈련1. 큐 자료구조를 구현하라.

- Queue.java
    - 제네릭을 적용한다.
    - 객체 복제가 가능하도록 Cloneable 인터페이스를 구현한다.


### 훈련2. 사용자가 입력한 명령어를 큐에 보관하라.

- App.java
    - 사용자가 입력한 명령어를 큐에 보관한다.


### 훈련3. 사용자가 입력한 명령을 입력한 순서로 출력하는 `history2` 명령을 추가하라.

- App.java
    - 명령어 내역을 출력하는 printCommandHistory2()를 정의한다.
    - `history2` 명령을 처리하는 분기문을 추가한다.

#### 실행 결과

```
명령> history2
history
/board/detail
/member/list
/stuff/add
/stuff/list
:  <== 키보드에서 ‘q’가 아닌 다른 문자키를 누른다.
/board/add
/member/list
/member/list
/board/add
/board/add
:q  <== 키보드에서 ‘q’ 키를 누른다.
명령>

```

### 추가사항

Object의 clone() 메소드를 재정의하면 얕은 복사를 수행한다. Queue에서 poll()을 수행하면 first 노드를 삭제하게 되고, 이때 원본 객체의 노드가 링크 정보를 잃게 된다. 따라서 다시 복제를 수행하면 제대로 작업이 수행될 수 없다. 해결책은 원본 객체가 사용하는 노드도 함께 복제하는 깊은 복사를 수행해야 한다.

Stack의 경우는 배열을 복사하면 되기 때문에 기존의 얕은 복사를 수행한 후 배열을 따로 복사했다. 하지만 연결리스트의 경우 노드와 노드 사이를 연결해야 하기 때문에 단순히 얕은 복사를 수행해서는 안된다. 현재 코드와 같이 새로운 Queue를 만들고 기존 Queue에서 저장된 값을 꺼내서 새 Queue에 저장해야한다. 결국 add() 메소드를 통해 새로운 노드가 생성되며 새로운 링크가 만들어지기 때문이다.